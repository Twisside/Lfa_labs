# Parser nad AST

### Course: Formal Languages & Finite Automata
### Author: Timciuc Ana-Maria

----

## Theory
Parsers analyze input based on rules to understand its structure. They break down the input into smaller units (tokens) and organize them into a hierarchical structure.

Abstract Syntax Trees (ASTs) represent this structure in a simplified form, abstracting away syntax details. They're used in compilers and interpreters to understand and manipulate code efficiently.

## Objectives:

1. Get familiar with parsing, what it is and how it can be programmed [1]. 
2. Get familiar with the concept of AST [2]. 
3. In addition to what has been done in the 3rd lab work do the following:
   1. In case you didn't have a type that denotes the possible types of tokens you need to:
      1. Have a type TokenType (like an enum) that can be used in the lexical analysis to categorize the tokens. 
      2. Please use regular expressions to identify the type of the token.
   2. Implement the necessary data structures for an AST that could be used for the text you have processed in the 3rd lab work.
   3. Implement a simple parser program that could extract the syntactic information from the input text.


## Implementation description

1. Token Types Enumeration (TokenType):

Defines an enumeration to represent the different types of tokens that the lexer will recognize, 
such as numbers, arithmetic operators, keywords (e.g., "int", "float"), identifiers (variable names), and special characters (e.g., semicolon).

```csharp
public enum TokenType // Tocken types enumeration modified for the convenience of parsing
{
    Identifier,
    Integer,
    Float,
    Plus,
    Minus,
    Multiply,
    Divide,
    LeftParenthesis,
    RightParenthesis,
    Semicolon,
    Equal,
    Int,
    FloatKeyword,
    Unknown,
    EOF
}
```

2. Token Class:

Represents a token with properties for its type and value. This class is used to store individual tokens generated by the lexer during the tokenization process.

3. Parser Class:

* This class is a parser implemented in C#. It's designed to parse input expressions and generate an Abstract Syntax Tree (AST) representing their structure. 
* Methods:
  * Parse(): Public method to start the parsing process. It returns the root node of the generated AST.
  * Expr(): Parses arithmetic expressions, such as addition and subtraction.
  * Term(): Parses terms in an expression, such as multiplication and division.
  * Factor(): Parses factors in an expression, such as integers, floats, identifiers (variables), and parenthesized expressions.

```csharp
 public AstNode Parse()
    {
        return Expr(); 
    }

    private AstNode Expr() // one of the methods ass an example
    {
        var node = Term();

        while (currentToken.Type == TokenType.Plus || currentToken.Type == TokenType.Minus)
        {   
            var token = currentToken;
            if (token.Type == TokenType.Plus) // identifying the operation
            {
                Eat(TokenType.Plus);
                node = new AddNode(node, Term()); // creating the corresponding node
            }
            else if (token.Type == TokenType.Minus)
            {
                Eat(TokenType.Minus);
                node = new AddNode(node, new IntNode(-1 * ((IntNode)Term()).Value));
            }
        }

        return node;
    }
```
4. ASt Classes
* This class defines a set of classes for building an Abstract Syntax Tree (AST) in the context of a specific grammar.
    * IntNode: Represents an integer value in the AST. It has a property Value to store the integer value.
    * FloatNode: Represents a floating-point value in the AST. It has a property Value to store the float value.
    * VariableNode: Represents a variable (identifier) in the AST. It has a property Name to store the variable name.
    * AddNode: Represents an addition operation in the AST. It has properties Left and Right to store the left and right operands, respectively.
    * MultiplyNode: Represents a multiplication operation in the AST. It also has properties Left and Right to store the operands.
```csharp
public class IntNode : AstNode
{
    public int Value { get; }

    public IntNode(int value) // int node for storing the integer value
    {
        Value = value;
    }

    public override void Print(int depth)
    {
        Console.WriteLine($"{new string(' ', depth * 4)}IntNode: {Value}"); // printing the "tree" by depth of the node
    }
}

public class AddNode : AstNode // represents an addition operation in the AST
{
    public AstNode Left { get; }
    public AstNode Right { get; }

    public AddNode(AstNode left, AstNode right) // assigning sides to the value nodes
    {
        Left = left;
        Right = right;
    }

    public override void Print(int depth)
    {
        Console.WriteLine($"{new string(' ', depth * 4)}AddNode:"); // printing the "tree" by depth of the node
        Left.Print(depth + 1);
        Right.Print(depth + 1);
    }
}

public class MultiplyNode : AstNode // class that represents a multiplication operation in the AST
{
    public AstNode Left { get; }
    public AstNode Right { get; }

    public MultiplyNode(AstNode left, AstNode right) // assigning sides to the value nodes
    {
        Left = left;
        Right = right;
    }

    public override void Print(int depth)
    {
        Console.WriteLine($"{new string(' ', depth * 4)}MultiplyNode:"); // printing the "tree" by depth of the node
        Left.Print(depth + 1);
        Right.Print(depth + 1);
    }
}
```


## Conclusions 


In conclusion, I'm satisfied with the progress made on implementing the AST (Abstract Syntax Tree) and related classes for the given tasks (although the implementation is funky). Building the parser and AST involved careful consideration of the grammar rules and the design of the data structures to represent the syntactic elements of the input expressions effectively.
* input: 
```
2 + 3 * (4 - 2)
```
* output:
``` 
AddNode:
    IntNode: 2
    MultiplyNode:
        IntNode: 3
        SubtractNode:
            IntNode: 4
            IntNode: 2
```
